/*
 *	event.h
 * External interface and defines to input-queue event handling
 * routines.
 * Written by Wade Olsen for Silicon Graphics, Inc.
 */

/*
 *	The event handler understands two kinds of things; events and
 * updates.  Events are reactions to things occuring in the input
 * queue.  Updates are functions that should be called whenever there
 * is nothing waiting in the input queue, and may be active or
 * inactive.  If there are no active updates and nothing in the input
 * queue, then event() will block, using up no CPU time.
 *
 * add_event is used to look for events.  The first three arguments
 * are used to identify which event to look for.  The first argument
 * is the window (gid) the event must happen in; if this value is ANY
 * then any window will do.  The second argument is the device to look
 * for (e.g.  RIGHTMOUSE or REDRAW or KEYBD, etc).  Again, if it is
 * ANY then any device will match.  The third argument is the value
 * the device must generate (e.g.  DOWN or UP); ANY means all values
 * match.  The last two arguments are what should be done when an
 * event is generated.  The fourth argument is a function to be
 * called, and the fifth is an argument that should be supplied to the
 * function.  In addition, the value generated by the device will also
 * be passed to the function when it is called.
 *
 * For example,
 *	add_event(winget(), RIGHTMOUSE, DOWN, dopup, my_menus);
 *	qdevice(RIGHTMOUSE);
 * will make a pop-up menu appear when the right mousebutton goes
 * down.  Note that you must do the qdevice() call yourself.
 */
void add_event(int, int, int, void (*fn)(void *, int), char *) ;

/*
 * An update is like an event, only simpler.  The first argument is a
 * pointer to an integer flag specifying whether or not this update
 * function is active.  The second is a function to be called when it
 * is active, and the last is an argument to be supplied to the
 * function.
 */
void add_update(int *, void (*fn)(void), char *) ;

/*
 * Finally, when all updates and events have been added, repeatedly
 * call event() to handle them -- something like
 * 
 *	while (quitflag == FALSE) event();
 * 
 * You should have previously added an event that sets quitflag to
 * TRUE, of course.
 */
void event(void) ;

/*
 *	These are some useful defines for the possible values buttons
 * can generate.
 */
#define ANY	-1
#define UP	0
#define DOWN	1

/*
 *	And a few external variables you might find useful
 */
extern int context, state, device;
